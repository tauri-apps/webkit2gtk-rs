// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/tauri-apps/gir-files)
// DO NOT EDIT

use glib::{prelude::*, translate::*};

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAuthenticationScheme")]
pub enum AuthenticationScheme {
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_DEFAULT")]
  Default,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC")]
  HttpBasic,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST")]
  HttpDigest,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM")]
  HtmlForm,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NTLM")]
  Ntlm,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE")]
  Negotiate,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED")]
  ClientCertificateRequested,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED")]
  ServerTrustEvaluationRequested,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED")]
  ClientCertificatePinRequested,
  #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN")]
  Unknown,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl IntoGlib for AuthenticationScheme {
  type GlibType = ffi::WebKitAuthenticationScheme;

  #[inline]
  fn into_glib(self) -> ffi::WebKitAuthenticationScheme {
    match self {
      Self::Default => ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT,
      Self::HttpBasic => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC,
      Self::HttpDigest => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST,
      Self::HtmlForm => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM,
      Self::Ntlm => ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM,
      Self::Negotiate => ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE,
      Self::ClientCertificateRequested => {
        ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED
      }
      Self::ServerTrustEvaluationRequested => {
        ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED
      }
      Self::ClientCertificatePinRequested => {
        ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED
      }
      Self::Unknown => ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAuthenticationScheme> for AuthenticationScheme {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitAuthenticationScheme) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT => Self::Default,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC => Self::HttpBasic,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST => Self::HttpDigest,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM => Self::HtmlForm,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM => Self::Ntlm,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE => Self::Negotiate,
      ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED => {
        Self::ClientCertificateRequested
      }
      ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED => {
        Self::ServerTrustEvaluationRequested
      }
      ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED => {
        Self::ClientCertificatePinRequested
      }
      ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN => Self::Unknown,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl StaticType for AuthenticationScheme {
  #[inline]
  #[doc(alias = "webkit_authentication_scheme_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_authentication_scheme_get_type()) }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl glib::HasParamSpec for AuthenticationScheme {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl glib::value::ValueType for AuthenticationScheme {
  type Type = Self;
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for AuthenticationScheme {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl ToValue for AuthenticationScheme {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl From<AuthenticationScheme> for glib::Value {
  #[inline]
  fn from(v: AuthenticationScheme) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutomationBrowsingContextPresentation")]
pub enum AutomationBrowsingContextPresentation {
  #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW")]
  Window,
  #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB")]
  Tab,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl IntoGlib for AutomationBrowsingContextPresentation {
  type GlibType = ffi::WebKitAutomationBrowsingContextPresentation;

  #[inline]
  fn into_glib(self) -> ffi::WebKitAutomationBrowsingContextPresentation {
    match self {
      Self::Window => ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW,
      Self::Tab => ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutomationBrowsingContextPresentation>
  for AutomationBrowsingContextPresentation
{
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitAutomationBrowsingContextPresentation) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW => Self::Window,
      ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB => Self::Tab,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl StaticType for AutomationBrowsingContextPresentation {
  #[inline]
  #[doc(alias = "webkit_automation_browsing_context_presentation_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_automation_browsing_context_presentation_get_type()) }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::HasParamSpec for AutomationBrowsingContextPresentation {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::value::ValueType for AutomationBrowsingContextPresentation {
  type Type = Self;
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
unsafe impl<'a> glib::value::FromValue<'a> for AutomationBrowsingContextPresentation {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl ToValue for AutomationBrowsingContextPresentation {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl From<AutomationBrowsingContextPresentation> for glib::Value {
  #[inline]
  fn from(v: AutomationBrowsingContextPresentation) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutoplayPolicy")]
pub enum AutoplayPolicy {
  #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW")]
  Allow,
  #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND")]
  AllowWithoutSound,
  #[doc(alias = "WEBKIT_AUTOPLAY_DENY")]
  Deny,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl IntoGlib for AutoplayPolicy {
  type GlibType = ffi::WebKitAutoplayPolicy;

  #[inline]
  fn into_glib(self) -> ffi::WebKitAutoplayPolicy {
    match self {
      Self::Allow => ffi::WEBKIT_AUTOPLAY_ALLOW,
      Self::AllowWithoutSound => ffi::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND,
      Self::Deny => ffi::WEBKIT_AUTOPLAY_DENY,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutoplayPolicy> for AutoplayPolicy {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitAutoplayPolicy) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_AUTOPLAY_ALLOW => Self::Allow,
      ffi::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND => Self::AllowWithoutSound,
      ffi::WEBKIT_AUTOPLAY_DENY => Self::Deny,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
impl StaticType for AutoplayPolicy {
  #[inline]
  #[doc(alias = "webkit_autoplay_policy_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_autoplay_policy_get_type()) }
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
impl glib::HasParamSpec for AutoplayPolicy {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
impl glib::value::ValueType for AutoplayPolicy {
  type Type = Self;
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
unsafe impl<'a> glib::value::FromValue<'a> for AutoplayPolicy {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
impl ToValue for AutoplayPolicy {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_30")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_30")))]
impl From<AutoplayPolicy> for glib::Value {
  #[inline]
  fn from(v: AutoplayPolicy) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCacheModel")]
pub enum CacheModel {
  #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER")]
  DocumentViewer,
  #[doc(alias = "WEBKIT_CACHE_MODEL_WEB_BROWSER")]
  WebBrowser,
  #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER")]
  DocumentBrowser,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CacheModel {
  type GlibType = ffi::WebKitCacheModel;

  #[inline]
  fn into_glib(self) -> ffi::WebKitCacheModel {
    match self {
      Self::DocumentViewer => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER,
      Self::WebBrowser => ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER,
      Self::DocumentBrowser => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCacheModel> for CacheModel {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitCacheModel) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER => Self::DocumentViewer,
      ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER => Self::WebBrowser,
      ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER => Self::DocumentBrowser,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for CacheModel {
  #[inline]
  #[doc(alias = "webkit_cache_model_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_cache_model_get_type()) }
  }
}

impl glib::HasParamSpec for CacheModel {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for CacheModel {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CacheModel {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for CacheModel {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<CacheModel> for glib::Value {
  #[inline]
  fn from(v: CacheModel) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitContextMenuAction")]
pub enum ContextMenuAction {
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION")]
  NoAction,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK")]
  OpenLink,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW")]
  OpenLinkInNewWindow,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK")]
  DownloadLinkToDisk,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD")]
  CopyLinkToClipboard,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW")]
  OpenImageInNewWindow,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK")]
  DownloadImageToDisk,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD")]
  CopyImageToClipboard,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD")]
  CopyImageUrlToClipboard,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW")]
  OpenFrameInNewWindow,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_BACK")]
  GoBack,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD")]
  GoForward,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_STOP")]
  Stop,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_RELOAD")]
  Reload,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY")]
  Copy,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUT")]
  Cut,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_PASTE")]
  Paste,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DELETE")]
  Delete,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL")]
  SelectAll,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS")]
  InputMethods,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_UNICODE")]
  Unicode,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS")]
  SpellingGuess,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND")]
  NoGuessesFound,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING")]
  IgnoreSpelling,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING")]
  LearnSpelling,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR")]
  IgnoreGrammar,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU")]
  FontMenu,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_BOLD")]
  Bold,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ITALIC")]
  Italic,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE")]
  Underline,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OUTLINE")]
  Outline,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT")]
  InspectElement,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW")]
  OpenVideoInNewWindow,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW")]
  OpenAudioInNewWindow,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD")]
  CopyVideoLinkToClipboard,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD")]
  CopyAudioLinkToClipboard,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS")]
  ToggleMediaControls,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP")]
  ToggleMediaLoop,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN")]
  EnterVideoFullscreen,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY")]
  MediaPlay,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE")]
  MediaPause,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE")]
  MediaMute,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK")]
  DownloadVideoToDisk,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK")]
  DownloadAudioToDisk,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI")]
  InsertEmoji,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_PASTE_AS_PLAIN_TEXT")]
  PasteAsPlainText,
  #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUSTOM")]
  Custom,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ContextMenuAction {
  type GlibType = ffi::WebKitContextMenuAction;

  fn into_glib(self) -> ffi::WebKitContextMenuAction {
    match self {
      Self::NoAction => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION,
      Self::OpenLink => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK,
      Self::OpenLinkInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW,
      Self::DownloadLinkToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK,
      Self::CopyLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD,
      Self::OpenImageInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW,
      Self::DownloadImageToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK,
      Self::CopyImageToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD,
      Self::CopyImageUrlToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD,
      Self::OpenFrameInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW,
      Self::GoBack => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK,
      Self::GoForward => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD,
      Self::Stop => ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP,
      Self::Reload => ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD,
      Self::Copy => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY,
      Self::Cut => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT,
      Self::Paste => ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE,
      Self::Delete => ffi::WEBKIT_CONTEXT_MENU_ACTION_DELETE,
      Self::SelectAll => ffi::WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL,
      Self::InputMethods => ffi::WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS,
      Self::Unicode => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNICODE,
      Self::SpellingGuess => ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS,
      Self::NoGuessesFound => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND,
      Self::IgnoreSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING,
      Self::LearnSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING,
      Self::IgnoreGrammar => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR,
      Self::FontMenu => ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU,
      Self::Bold => ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD,
      Self::Italic => ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC,
      Self::Underline => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE,
      Self::Outline => ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE,
      Self::InspectElement => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT,
      Self::OpenVideoInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW,
      Self::OpenAudioInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW,
      Self::CopyVideoLinkToClipboard => {
        ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD
      }
      Self::CopyAudioLinkToClipboard => {
        ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD
      }
      Self::ToggleMediaControls => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS,
      Self::ToggleMediaLoop => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP,
      Self::EnterVideoFullscreen => ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN,
      Self::MediaPlay => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY,
      Self::MediaPause => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE,
      Self::MediaMute => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE,
      Self::DownloadVideoToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK,
      Self::DownloadAudioToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK,
      Self::InsertEmoji => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI,
      Self::PasteAsPlainText => ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE_AS_PLAIN_TEXT,
      Self::Custom => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitContextMenuAction> for ContextMenuAction {
  unsafe fn from_glib(value: ffi::WebKitContextMenuAction) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION => Self::NoAction,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK => Self::OpenLink,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW => Self::OpenLinkInNewWindow,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK => Self::DownloadLinkToDisk,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD => Self::CopyLinkToClipboard,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW => Self::OpenImageInNewWindow,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK => Self::DownloadImageToDisk,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD => Self::CopyImageToClipboard,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD => Self::CopyImageUrlToClipboard,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW => Self::OpenFrameInNewWindow,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK => Self::GoBack,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD => Self::GoForward,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP => Self::Stop,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD => Self::Reload,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY => Self::Copy,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT => Self::Cut,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE => Self::Paste,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_DELETE => Self::Delete,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL => Self::SelectAll,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS => Self::InputMethods,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_UNICODE => Self::Unicode,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS => Self::SpellingGuess,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND => Self::NoGuessesFound,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING => Self::IgnoreSpelling,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING => Self::LearnSpelling,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR => Self::IgnoreGrammar,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU => Self::FontMenu,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD => Self::Bold,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC => Self::Italic,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE => Self::Underline,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE => Self::Outline,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT => Self::InspectElement,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW => Self::OpenVideoInNewWindow,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW => Self::OpenAudioInNewWindow,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD => {
        Self::CopyVideoLinkToClipboard
      }
      ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD => {
        Self::CopyAudioLinkToClipboard
      }
      ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS => Self::ToggleMediaControls,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP => Self::ToggleMediaLoop,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN => Self::EnterVideoFullscreen,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY => Self::MediaPlay,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE => Self::MediaPause,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE => Self::MediaMute,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK => Self::DownloadVideoToDisk,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK => Self::DownloadAudioToDisk,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_INSERT_EMOJI => Self::InsertEmoji,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE_AS_PLAIN_TEXT => Self::PasteAsPlainText,
      ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM => Self::Custom,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for ContextMenuAction {
  #[inline]
  #[doc(alias = "webkit_context_menu_action_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_context_menu_action_get_type()) }
  }
}

impl glib::HasParamSpec for ContextMenuAction {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for ContextMenuAction {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ContextMenuAction {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for ContextMenuAction {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<ContextMenuAction> for glib::Value {
  #[inline]
  fn from(v: ContextMenuAction) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookieAcceptPolicy")]
pub enum CookieAcceptPolicy {
  #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS")]
  Always,
  #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NEVER")]
  Never,
  #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY")]
  NoThirdParty,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CookieAcceptPolicy {
  type GlibType = ffi::WebKitCookieAcceptPolicy;

  #[inline]
  fn into_glib(self) -> ffi::WebKitCookieAcceptPolicy {
    match self {
      Self::Always => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS,
      Self::Never => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER,
      Self::NoThirdParty => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookieAcceptPolicy> for CookieAcceptPolicy {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitCookieAcceptPolicy) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS => Self::Always,
      ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER => Self::Never,
      ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY => Self::NoThirdParty,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for CookieAcceptPolicy {
  #[inline]
  #[doc(alias = "webkit_cookie_accept_policy_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_cookie_accept_policy_get_type()) }
  }
}

impl glib::HasParamSpec for CookieAcceptPolicy {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for CookieAcceptPolicy {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CookieAcceptPolicy {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for CookieAcceptPolicy {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<CookieAcceptPolicy> for glib::Value {
  #[inline]
  fn from(v: CookieAcceptPolicy) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookiePersistentStorage")]
pub enum CookiePersistentStorage {
  #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT")]
  Text,
  #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE")]
  Sqlite,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CookiePersistentStorage {
  type GlibType = ffi::WebKitCookiePersistentStorage;

  #[inline]
  fn into_glib(self) -> ffi::WebKitCookiePersistentStorage {
    match self {
      Self::Text => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT,
      Self::Sqlite => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookiePersistentStorage> for CookiePersistentStorage {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitCookiePersistentStorage) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT => Self::Text,
      ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE => Self::Sqlite,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for CookiePersistentStorage {
  #[inline]
  #[doc(alias = "webkit_cookie_persistent_storage_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_cookie_persistent_storage_get_type()) }
  }
}

impl glib::HasParamSpec for CookiePersistentStorage {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for CookiePersistentStorage {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CookiePersistentStorage {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for CookiePersistentStorage {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<CookiePersistentStorage> for glib::Value {
  #[inline]
  fn from(v: CookiePersistentStorage) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCredentialPersistence")]
pub enum CredentialPersistence {
  #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_NONE")]
  None,
  #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION")]
  ForSession,
  #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT")]
  Permanent,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl IntoGlib for CredentialPersistence {
  type GlibType = ffi::WebKitCredentialPersistence;

  #[inline]
  fn into_glib(self) -> ffi::WebKitCredentialPersistence {
    match self {
      Self::None => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE,
      Self::ForSession => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION,
      Self::Permanent => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitCredentialPersistence> for CredentialPersistence {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitCredentialPersistence) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE => Self::None,
      ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION => Self::ForSession,
      ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT => Self::Permanent,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl StaticType for CredentialPersistence {
  #[inline]
  #[doc(alias = "webkit_credential_persistence_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_credential_persistence_get_type()) }
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl glib::HasParamSpec for CredentialPersistence {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl glib::value::ValueType for CredentialPersistence {
  type Type = Self;
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
unsafe impl<'a> glib::value::FromValue<'a> for CredentialPersistence {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl ToValue for CredentialPersistence {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_2")))]
impl From<CredentialPersistence> for glib::Value {
  #[inline]
  fn from(v: CredentialPersistence) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitDownloadError")]
pub enum DownloadError {
  #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_NETWORK")]
  Network,
  #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER")]
  CancelledByUser,
  #[doc(alias = "WEBKIT_DOWNLOAD_ERROR_DESTINATION")]
  Destination,
  #[doc(hidden)]
  __Unknown(i32),
}

impl DownloadError {
  #[doc(alias = "webkit_download_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_download_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for DownloadError {
  type GlibType = ffi::WebKitDownloadError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitDownloadError {
    match self {
      Self::Network => ffi::WEBKIT_DOWNLOAD_ERROR_NETWORK,
      Self::CancelledByUser => ffi::WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER,
      Self::Destination => ffi::WEBKIT_DOWNLOAD_ERROR_DESTINATION,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitDownloadError> for DownloadError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitDownloadError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_DOWNLOAD_ERROR_NETWORK => Self::Network,
      ffi::WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER => Self::CancelledByUser,
      ffi::WEBKIT_DOWNLOAD_ERROR_DESTINATION => Self::Destination,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for DownloadError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitDownloadError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

impl StaticType for DownloadError {
  #[inline]
  #[doc(alias = "webkit_download_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_download_error_get_type()) }
  }
}

impl glib::HasParamSpec for DownloadError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for DownloadError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DownloadError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for DownloadError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<DownloadError> for glib::Value {
  #[inline]
  fn from(v: DownloadError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitFaviconDatabaseError")]
pub enum FaviconDatabaseError {
  #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED")]
  NotInitialized,
  #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND")]
  FaviconNotFound,
  #[doc(alias = "WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN")]
  FaviconUnknown,
  #[doc(hidden)]
  __Unknown(i32),
}

impl FaviconDatabaseError {
  #[doc(alias = "webkit_favicon_database_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_favicon_database_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for FaviconDatabaseError {
  type GlibType = ffi::WebKitFaviconDatabaseError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitFaviconDatabaseError {
    match self {
      Self::NotInitialized => ffi::WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED,
      Self::FaviconNotFound => ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND,
      Self::FaviconUnknown => ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitFaviconDatabaseError> for FaviconDatabaseError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitFaviconDatabaseError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED => Self::NotInitialized,
      ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND => Self::FaviconNotFound,
      ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN => Self::FaviconUnknown,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for FaviconDatabaseError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitFaviconDatabaseError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

impl StaticType for FaviconDatabaseError {
  #[inline]
  #[doc(alias = "webkit_favicon_database_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_favicon_database_error_get_type()) }
  }
}

impl glib::HasParamSpec for FaviconDatabaseError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for FaviconDatabaseError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FaviconDatabaseError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for FaviconDatabaseError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<FaviconDatabaseError> for glib::Value {
  #[inline]
  fn from(v: FaviconDatabaseError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitHardwareAccelerationPolicy")]
pub enum HardwareAccelerationPolicy {
  #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND")]
  OnDemand,
  #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS")]
  Always,
  #[doc(alias = "WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER")]
  Never,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl IntoGlib for HardwareAccelerationPolicy {
  type GlibType = ffi::WebKitHardwareAccelerationPolicy;

  #[inline]
  fn into_glib(self) -> ffi::WebKitHardwareAccelerationPolicy {
    match self {
      Self::OnDemand => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND,
      Self::Always => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS,
      Self::Never => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitHardwareAccelerationPolicy> for HardwareAccelerationPolicy {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitHardwareAccelerationPolicy) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND => Self::OnDemand,
      ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS => Self::Always,
      ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER => Self::Never,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl StaticType for HardwareAccelerationPolicy {
  #[inline]
  #[doc(alias = "webkit_hardware_acceleration_policy_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_hardware_acceleration_policy_get_type()) }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl glib::HasParamSpec for HardwareAccelerationPolicy {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl glib::value::ValueType for HardwareAccelerationPolicy {
  type Type = Self;
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for HardwareAccelerationPolicy {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl ToValue for HardwareAccelerationPolicy {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl From<HardwareAccelerationPolicy> for glib::Value {
  #[inline]
  fn from(v: HardwareAccelerationPolicy) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInputPurpose")]
pub enum InputPurpose {
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_FREE_FORM")]
  FreeForm,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_DIGITS")]
  Digits,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_NUMBER")]
  Number,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_PHONE")]
  Phone,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_URL")]
  Url,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_EMAIL")]
  Email,
  #[doc(alias = "WEBKIT_INPUT_PURPOSE_PASSWORD")]
  Password,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl IntoGlib for InputPurpose {
  type GlibType = ffi::WebKitInputPurpose;

  #[inline]
  fn into_glib(self) -> ffi::WebKitInputPurpose {
    match self {
      Self::FreeForm => ffi::WEBKIT_INPUT_PURPOSE_FREE_FORM,
      Self::Digits => ffi::WEBKIT_INPUT_PURPOSE_DIGITS,
      Self::Number => ffi::WEBKIT_INPUT_PURPOSE_NUMBER,
      Self::Phone => ffi::WEBKIT_INPUT_PURPOSE_PHONE,
      Self::Url => ffi::WEBKIT_INPUT_PURPOSE_URL,
      Self::Email => ffi::WEBKIT_INPUT_PURPOSE_EMAIL,
      Self::Password => ffi::WEBKIT_INPUT_PURPOSE_PASSWORD,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitInputPurpose> for InputPurpose {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitInputPurpose) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_INPUT_PURPOSE_FREE_FORM => Self::FreeForm,
      ffi::WEBKIT_INPUT_PURPOSE_DIGITS => Self::Digits,
      ffi::WEBKIT_INPUT_PURPOSE_NUMBER => Self::Number,
      ffi::WEBKIT_INPUT_PURPOSE_PHONE => Self::Phone,
      ffi::WEBKIT_INPUT_PURPOSE_URL => Self::Url,
      ffi::WEBKIT_INPUT_PURPOSE_EMAIL => Self::Email,
      ffi::WEBKIT_INPUT_PURPOSE_PASSWORD => Self::Password,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl StaticType for InputPurpose {
  #[inline]
  #[doc(alias = "webkit_input_purpose_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_input_purpose_get_type()) }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::HasParamSpec for InputPurpose {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::value::ValueType for InputPurpose {
  type Type = Self;
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
unsafe impl<'a> glib::value::FromValue<'a> for InputPurpose {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl ToValue for InputPurpose {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl From<InputPurpose> for glib::Value {
  #[inline]
  fn from(v: InputPurpose) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInsecureContentEvent")]
pub enum InsecureContentEvent {
  #[doc(alias = "WEBKIT_INSECURE_CONTENT_RUN")]
  Run,
  #[doc(alias = "WEBKIT_INSECURE_CONTENT_DISPLAYED")]
  Displayed,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for InsecureContentEvent {
  type GlibType = ffi::WebKitInsecureContentEvent;

  #[inline]
  fn into_glib(self) -> ffi::WebKitInsecureContentEvent {
    match self {
      Self::Run => ffi::WEBKIT_INSECURE_CONTENT_RUN,
      Self::Displayed => ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitInsecureContentEvent> for InsecureContentEvent {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitInsecureContentEvent) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_INSECURE_CONTENT_RUN => Self::Run,
      ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED => Self::Displayed,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for InsecureContentEvent {
  #[inline]
  #[doc(alias = "webkit_insecure_content_event_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_insecure_content_event_get_type()) }
  }
}

impl glib::HasParamSpec for InsecureContentEvent {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for InsecureContentEvent {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for InsecureContentEvent {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for InsecureContentEvent {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<InsecureContentEvent> for glib::Value {
  #[inline]
  fn from(v: InsecureContentEvent) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitJavascriptError")]
pub enum JavascriptError {
  #[doc(alias = "WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED")]
  ScriptFailed,
  #[doc(alias = "WEBKIT_JAVASCRIPT_ERROR_INVALID_PARAMETER")]
  InvalidParameter,
  #[doc(alias = "WEBKIT_JAVASCRIPT_ERROR_INVALID_RESULT")]
  InvalidResult,
  #[doc(hidden)]
  __Unknown(i32),
}

impl JavascriptError {
  #[doc(alias = "webkit_javascript_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_javascript_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for JavascriptError {
  type GlibType = ffi::WebKitJavascriptError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitJavascriptError {
    match self {
      Self::ScriptFailed => ffi::WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED,
      Self::InvalidParameter => ffi::WEBKIT_JAVASCRIPT_ERROR_INVALID_PARAMETER,
      Self::InvalidResult => ffi::WEBKIT_JAVASCRIPT_ERROR_INVALID_RESULT,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitJavascriptError> for JavascriptError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitJavascriptError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED => Self::ScriptFailed,
      ffi::WEBKIT_JAVASCRIPT_ERROR_INVALID_PARAMETER => Self::InvalidParameter,
      ffi::WEBKIT_JAVASCRIPT_ERROR_INVALID_RESULT => Self::InvalidResult,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for JavascriptError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitJavascriptError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

impl StaticType for JavascriptError {
  #[inline]
  #[doc(alias = "webkit_javascript_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_javascript_error_get_type()) }
  }
}

impl glib::HasParamSpec for JavascriptError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for JavascriptError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for JavascriptError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for JavascriptError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<JavascriptError> for glib::Value {
  #[inline]
  fn from(v: JavascriptError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitLoadEvent")]
pub enum LoadEvent {
  #[doc(alias = "WEBKIT_LOAD_STARTED")]
  Started,
  #[doc(alias = "WEBKIT_LOAD_REDIRECTED")]
  Redirected,
  #[doc(alias = "WEBKIT_LOAD_COMMITTED")]
  Committed,
  #[doc(alias = "WEBKIT_LOAD_FINISHED")]
  Finished,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for LoadEvent {
  type GlibType = ffi::WebKitLoadEvent;

  #[inline]
  fn into_glib(self) -> ffi::WebKitLoadEvent {
    match self {
      Self::Started => ffi::WEBKIT_LOAD_STARTED,
      Self::Redirected => ffi::WEBKIT_LOAD_REDIRECTED,
      Self::Committed => ffi::WEBKIT_LOAD_COMMITTED,
      Self::Finished => ffi::WEBKIT_LOAD_FINISHED,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitLoadEvent> for LoadEvent {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitLoadEvent) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_LOAD_STARTED => Self::Started,
      ffi::WEBKIT_LOAD_REDIRECTED => Self::Redirected,
      ffi::WEBKIT_LOAD_COMMITTED => Self::Committed,
      ffi::WEBKIT_LOAD_FINISHED => Self::Finished,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for LoadEvent {
  #[inline]
  #[doc(alias = "webkit_load_event_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_load_event_get_type()) }
  }
}

impl glib::HasParamSpec for LoadEvent {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for LoadEvent {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for LoadEvent {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for LoadEvent {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<LoadEvent> for glib::Value {
  #[inline]
  fn from(v: LoadEvent) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitMediaCaptureState")]
pub enum MediaCaptureState {
  #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_NONE")]
  None,
  #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE")]
  Active,
  #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_MUTED")]
  Muted,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
#[doc(hidden)]
impl IntoGlib for MediaCaptureState {
  type GlibType = ffi::WebKitMediaCaptureState;

  #[inline]
  fn into_glib(self) -> ffi::WebKitMediaCaptureState {
    match self {
      Self::None => ffi::WEBKIT_MEDIA_CAPTURE_STATE_NONE,
      Self::Active => ffi::WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE,
      Self::Muted => ffi::WEBKIT_MEDIA_CAPTURE_STATE_MUTED,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitMediaCaptureState> for MediaCaptureState {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitMediaCaptureState) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_MEDIA_CAPTURE_STATE_NONE => Self::None,
      ffi::WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE => Self::Active,
      ffi::WEBKIT_MEDIA_CAPTURE_STATE_MUTED => Self::Muted,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
impl StaticType for MediaCaptureState {
  #[inline]
  #[doc(alias = "webkit_media_capture_state_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_media_capture_state_get_type()) }
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
impl glib::HasParamSpec for MediaCaptureState {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
impl glib::value::ValueType for MediaCaptureState {
  type Type = Self;
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
unsafe impl<'a> glib::value::FromValue<'a> for MediaCaptureState {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
impl ToValue for MediaCaptureState {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_34")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_34")))]
impl From<MediaCaptureState> for glib::Value {
  #[inline]
  fn from(v: MediaCaptureState) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNavigationType")]
pub enum NavigationType {
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_LINK_CLICKED")]
  LinkClicked,
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED")]
  FormSubmitted,
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_BACK_FORWARD")]
  BackForward,
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_RELOAD")]
  Reload,
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED")]
  FormResubmitted,
  #[doc(alias = "WEBKIT_NAVIGATION_TYPE_OTHER")]
  Other,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for NavigationType {
  type GlibType = ffi::WebKitNavigationType;

  #[inline]
  fn into_glib(self) -> ffi::WebKitNavigationType {
    match self {
      Self::LinkClicked => ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED,
      Self::FormSubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED,
      Self::BackForward => ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD,
      Self::Reload => ffi::WEBKIT_NAVIGATION_TYPE_RELOAD,
      Self::FormResubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED,
      Self::Other => ffi::WEBKIT_NAVIGATION_TYPE_OTHER,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNavigationType> for NavigationType {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitNavigationType) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED => Self::LinkClicked,
      ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED => Self::FormSubmitted,
      ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD => Self::BackForward,
      ffi::WEBKIT_NAVIGATION_TYPE_RELOAD => Self::Reload,
      ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED => Self::FormResubmitted,
      ffi::WEBKIT_NAVIGATION_TYPE_OTHER => Self::Other,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for NavigationType {
  #[inline]
  #[doc(alias = "webkit_navigation_type_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_navigation_type_get_type()) }
  }
}

impl glib::HasParamSpec for NavigationType {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for NavigationType {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NavigationType {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for NavigationType {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<NavigationType> for glib::Value {
  #[inline]
  fn from(v: NavigationType) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNetworkError")]
pub enum NetworkError {
  #[doc(alias = "WEBKIT_NETWORK_ERROR_FAILED")]
  Failed,
  #[doc(alias = "WEBKIT_NETWORK_ERROR_TRANSPORT")]
  Transport,
  #[doc(alias = "WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL")]
  UnknownProtocol,
  #[doc(alias = "WEBKIT_NETWORK_ERROR_CANCELLED")]
  Cancelled,
  #[doc(alias = "WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST")]
  FileDoesNotExist,
  #[doc(hidden)]
  __Unknown(i32),
}

impl NetworkError {
  #[doc(alias = "webkit_network_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_network_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for NetworkError {
  type GlibType = ffi::WebKitNetworkError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitNetworkError {
    match self {
      Self::Failed => ffi::WEBKIT_NETWORK_ERROR_FAILED,
      Self::Transport => ffi::WEBKIT_NETWORK_ERROR_TRANSPORT,
      Self::UnknownProtocol => ffi::WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL,
      Self::Cancelled => ffi::WEBKIT_NETWORK_ERROR_CANCELLED,
      Self::FileDoesNotExist => ffi::WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkError> for NetworkError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitNetworkError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_NETWORK_ERROR_FAILED => Self::Failed,
      ffi::WEBKIT_NETWORK_ERROR_TRANSPORT => Self::Transport,
      ffi::WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL => Self::UnknownProtocol,
      ffi::WEBKIT_NETWORK_ERROR_CANCELLED => Self::Cancelled,
      ffi::WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST => Self::FileDoesNotExist,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for NetworkError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitNetworkError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      Self::__Unknown(_) => Some(Self::Failed),
      value => Some(value),
    }
  }
}

impl StaticType for NetworkError {
  #[inline]
  #[doc(alias = "webkit_network_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_network_error_get_type()) }
  }
}

impl glib::HasParamSpec for NetworkError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for NetworkError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NetworkError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for NetworkError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<NetworkError> for glib::Value {
  #[inline]
  fn from(v: NetworkError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNetworkProxyMode")]
pub enum NetworkProxyMode {
  #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_DEFAULT")]
  Default,
  #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_NO_PROXY")]
  NoProxy,
  #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_CUSTOM")]
  Custom,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl IntoGlib for NetworkProxyMode {
  type GlibType = ffi::WebKitNetworkProxyMode;

  #[inline]
  fn into_glib(self) -> ffi::WebKitNetworkProxyMode {
    match self {
      Self::Default => ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT,
      Self::NoProxy => ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY,
      Self::Custom => ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkProxyMode> for NetworkProxyMode {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitNetworkProxyMode) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT => Self::Default,
      ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY => Self::NoProxy,
      ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM => Self::Custom,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl StaticType for NetworkProxyMode {
  #[inline]
  #[doc(alias = "webkit_network_proxy_mode_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_network_proxy_mode_get_type()) }
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl glib::HasParamSpec for NetworkProxyMode {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl glib::value::ValueType for NetworkProxyMode {
  type Type = Self;
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for NetworkProxyMode {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl ToValue for NetworkProxyMode {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_16")))]
impl From<NetworkProxyMode> for glib::Value {
  #[inline]
  fn from(v: NetworkProxyMode) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPluginError")]
pub enum PluginError {
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_FAILED")]
  Failed,
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN")]
  CannotFindPlugin,
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN")]
  CannotLoadPlugin,
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE")]
  JavaUnavailable,
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED")]
  ConnectionCancelled,
  #[doc(alias = "WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD")]
  WillHandleLoad,
  #[doc(hidden)]
  __Unknown(i32),
}

impl PluginError {
  #[doc(alias = "webkit_plugin_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_plugin_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for PluginError {
  type GlibType = ffi::WebKitPluginError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitPluginError {
    match self {
      Self::Failed => ffi::WEBKIT_PLUGIN_ERROR_FAILED,
      Self::CannotFindPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN,
      Self::CannotLoadPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN,
      Self::JavaUnavailable => ffi::WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE,
      Self::ConnectionCancelled => ffi::WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED,
      Self::WillHandleLoad => ffi::WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPluginError> for PluginError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitPluginError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_PLUGIN_ERROR_FAILED => Self::Failed,
      ffi::WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN => Self::CannotFindPlugin,
      ffi::WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN => Self::CannotLoadPlugin,
      ffi::WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE => Self::JavaUnavailable,
      ffi::WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED => Self::ConnectionCancelled,
      ffi::WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD => Self::WillHandleLoad,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for PluginError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitPluginError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      Self::__Unknown(_) => Some(Self::Failed),
      value => Some(value),
    }
  }
}

impl StaticType for PluginError {
  #[inline]
  #[doc(alias = "webkit_plugin_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_plugin_error_get_type()) }
  }
}

impl glib::HasParamSpec for PluginError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for PluginError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PluginError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for PluginError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<PluginError> for glib::Value {
  #[inline]
  fn from(v: PluginError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPolicyDecisionType")]
pub enum PolicyDecisionType {
  #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION")]
  NavigationAction,
  #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION")]
  NewWindowAction,
  #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_RESPONSE")]
  Response,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PolicyDecisionType {
  type GlibType = ffi::WebKitPolicyDecisionType;

  #[inline]
  fn into_glib(self) -> ffi::WebKitPolicyDecisionType {
    match self {
      Self::NavigationAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION,
      Self::NewWindowAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION,
      Self::Response => ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyDecisionType> for PolicyDecisionType {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitPolicyDecisionType) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION => Self::NavigationAction,
      ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION => Self::NewWindowAction,
      ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE => Self::Response,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for PolicyDecisionType {
  #[inline]
  #[doc(alias = "webkit_policy_decision_type_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_policy_decision_type_get_type()) }
  }
}

impl glib::HasParamSpec for PolicyDecisionType {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for PolicyDecisionType {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PolicyDecisionType {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for PolicyDecisionType {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<PolicyDecisionType> for glib::Value {
  #[inline]
  fn from(v: PolicyDecisionType) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPolicyError")]
pub enum PolicyError {
  #[doc(alias = "WEBKIT_POLICY_ERROR_FAILED")]
  Failed,
  #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE")]
  CannotShowMimeType,
  #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI")]
  CannotShowUri,
  #[doc(alias = "WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE")]
  FrameLoadInterruptedByPolicyChange,
  #[doc(alias = "WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT")]
  CannotUseRestrictedPort,
  #[doc(hidden)]
  __Unknown(i32),
}

impl PolicyError {
  #[doc(alias = "webkit_policy_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_policy_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for PolicyError {
  type GlibType = ffi::WebKitPolicyError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitPolicyError {
    match self {
      Self::Failed => ffi::WEBKIT_POLICY_ERROR_FAILED,
      Self::CannotShowMimeType => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE,
      Self::CannotShowUri => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI,
      Self::FrameLoadInterruptedByPolicyChange => {
        ffi::WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE
      }
      Self::CannotUseRestrictedPort => ffi::WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyError> for PolicyError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitPolicyError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_POLICY_ERROR_FAILED => Self::Failed,
      ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE => Self::CannotShowMimeType,
      ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI => Self::CannotShowUri,
      ffi::WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE => {
        Self::FrameLoadInterruptedByPolicyChange
      }
      ffi::WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT => Self::CannotUseRestrictedPort,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for PolicyError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitPolicyError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      Self::__Unknown(_) => Some(Self::Failed),
      value => Some(value),
    }
  }
}

impl StaticType for PolicyError {
  #[inline]
  #[doc(alias = "webkit_policy_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_policy_error_get_type()) }
  }
}

impl glib::HasParamSpec for PolicyError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for PolicyError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PolicyError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for PolicyError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<PolicyError> for glib::Value {
  #[inline]
  fn from(v: PolicyError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPrintError")]
pub enum PrintError {
  #[doc(alias = "WEBKIT_PRINT_ERROR_GENERAL")]
  General,
  #[doc(alias = "WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND")]
  PrinterNotFound,
  #[doc(alias = "WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE")]
  InvalidPageRange,
  #[doc(hidden)]
  __Unknown(i32),
}

impl PrintError {
  #[doc(alias = "webkit_print_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_print_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for PrintError {
  type GlibType = ffi::WebKitPrintError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitPrintError {
    match self {
      Self::General => ffi::WEBKIT_PRINT_ERROR_GENERAL,
      Self::PrinterNotFound => ffi::WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND,
      Self::InvalidPageRange => ffi::WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintError> for PrintError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitPrintError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_PRINT_ERROR_GENERAL => Self::General,
      ffi::WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND => Self::PrinterNotFound,
      ffi::WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE => Self::InvalidPageRange,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for PrintError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitPrintError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

impl StaticType for PrintError {
  #[inline]
  #[doc(alias = "webkit_print_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_print_error_get_type()) }
  }
}

impl glib::HasParamSpec for PrintError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for PrintError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for PrintError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<PrintError> for glib::Value {
  #[inline]
  fn from(v: PrintError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPrintOperationResponse")]
pub enum PrintOperationResponse {
  #[doc(alias = "WEBKIT_PRINT_OPERATION_RESPONSE_PRINT")]
  Print,
  #[doc(alias = "WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL")]
  Cancel,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PrintOperationResponse {
  type GlibType = ffi::WebKitPrintOperationResponse;

  #[inline]
  fn into_glib(self) -> ffi::WebKitPrintOperationResponse {
    match self {
      Self::Print => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_PRINT,
      Self::Cancel => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintOperationResponse> for PrintOperationResponse {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitPrintOperationResponse) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_PRINT_OPERATION_RESPONSE_PRINT => Self::Print,
      ffi::WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL => Self::Cancel,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for PrintOperationResponse {
  #[inline]
  #[doc(alias = "webkit_print_operation_response_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_print_operation_response_get_type()) }
  }
}

impl glib::HasParamSpec for PrintOperationResponse {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for PrintOperationResponse {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PrintOperationResponse {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for PrintOperationResponse {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<PrintOperationResponse> for glib::Value {
  #[inline]
  fn from(v: PrintOperationResponse) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg_attr(feature = "v2_40", deprecated = "Since 2.40")]
#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitProcessModel")]
pub enum ProcessModel {
  #[doc(alias = "WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS")]
  SharedSecondaryProcess,
  #[doc(alias = "WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES")]
  MultipleSecondaryProcesses,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
#[doc(hidden)]
impl IntoGlib for ProcessModel {
  type GlibType = ffi::WebKitProcessModel;

  #[inline]
  fn into_glib(self) -> ffi::WebKitProcessModel {
    match self {
      Self::SharedSecondaryProcess => ffi::WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS,
      Self::MultipleSecondaryProcesses => ffi::WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
#[doc(hidden)]
impl FromGlib<ffi::WebKitProcessModel> for ProcessModel {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitProcessModel) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS => Self::SharedSecondaryProcess,
      ffi::WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES => Self::MultipleSecondaryProcesses,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
impl StaticType for ProcessModel {
  #[inline]
  #[doc(alias = "webkit_process_model_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_process_model_get_type()) }
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
impl glib::HasParamSpec for ProcessModel {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
impl glib::value::ValueType for ProcessModel {
  type Type = Self;
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
unsafe impl<'a> glib::value::FromValue<'a> for ProcessModel {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
impl ToValue for ProcessModel {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_4")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_4")))]
#[allow(deprecated)]
impl From<ProcessModel> for glib::Value {
  #[inline]
  fn from(v: ProcessModel) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSaveMode")]
pub enum SaveMode {
  #[doc(alias = "WEBKIT_SAVE_MODE_MHTML")]
  Mhtml,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SaveMode {
  type GlibType = ffi::WebKitSaveMode;

  #[inline]
  fn into_glib(self) -> ffi::WebKitSaveMode {
    match self {
      Self::Mhtml => ffi::WEBKIT_SAVE_MODE_MHTML,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSaveMode> for SaveMode {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitSaveMode) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_SAVE_MODE_MHTML => Self::Mhtml,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for SaveMode {
  #[inline]
  #[doc(alias = "webkit_save_mode_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_save_mode_get_type()) }
  }
}

impl glib::HasParamSpec for SaveMode {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for SaveMode {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SaveMode {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for SaveMode {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<SaveMode> for glib::Value {
  #[inline]
  fn from(v: SaveMode) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitScriptDialogType")]
pub enum ScriptDialogType {
  #[doc(alias = "WEBKIT_SCRIPT_DIALOG_ALERT")]
  Alert,
  #[doc(alias = "WEBKIT_SCRIPT_DIALOG_CONFIRM")]
  Confirm,
  #[doc(alias = "WEBKIT_SCRIPT_DIALOG_PROMPT")]
  Prompt,
  #[doc(alias = "WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM")]
  BeforeUnloadConfirm,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ScriptDialogType {
  type GlibType = ffi::WebKitScriptDialogType;

  #[inline]
  fn into_glib(self) -> ffi::WebKitScriptDialogType {
    match self {
      Self::Alert => ffi::WEBKIT_SCRIPT_DIALOG_ALERT,
      Self::Confirm => ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM,
      Self::Prompt => ffi::WEBKIT_SCRIPT_DIALOG_PROMPT,
      Self::BeforeUnloadConfirm => ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitScriptDialogType> for ScriptDialogType {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitScriptDialogType) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_SCRIPT_DIALOG_ALERT => Self::Alert,
      ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM => Self::Confirm,
      ffi::WEBKIT_SCRIPT_DIALOG_PROMPT => Self::Prompt,
      ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM => Self::BeforeUnloadConfirm,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for ScriptDialogType {
  #[inline]
  #[doc(alias = "webkit_script_dialog_type_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_script_dialog_type_get_type()) }
  }
}

impl glib::HasParamSpec for ScriptDialogType {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for ScriptDialogType {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ScriptDialogType {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for ScriptDialogType {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<ScriptDialogType> for glib::Value {
  #[inline]
  fn from(v: ScriptDialogType) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSnapshotError")]
pub enum SnapshotError {
  #[doc(alias = "WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE")]
  Create,
  #[doc(hidden)]
  __Unknown(i32),
}

impl SnapshotError {
  #[doc(alias = "webkit_snapshot_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_snapshot_error_quark()) }
  }
}

#[doc(hidden)]
impl IntoGlib for SnapshotError {
  type GlibType = ffi::WebKitSnapshotError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitSnapshotError {
    match self {
      Self::Create => ffi::WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotError> for SnapshotError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitSnapshotError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE => Self::Create,
      value => Self::__Unknown(value),
    }
  }
}

impl glib::error::ErrorDomain for SnapshotError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitSnapshotError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

impl StaticType for SnapshotError {
  #[inline]
  #[doc(alias = "webkit_snapshot_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_snapshot_error_get_type()) }
  }
}

impl glib::HasParamSpec for SnapshotError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for SnapshotError {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SnapshotError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for SnapshotError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<SnapshotError> for glib::Value {
  #[inline]
  fn from(v: SnapshotError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSnapshotRegion")]
pub enum SnapshotRegion {
  #[doc(alias = "WEBKIT_SNAPSHOT_REGION_VISIBLE")]
  Visible,
  #[doc(alias = "WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT")]
  FullDocument,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SnapshotRegion {
  type GlibType = ffi::WebKitSnapshotRegion;

  #[inline]
  fn into_glib(self) -> ffi::WebKitSnapshotRegion {
    match self {
      Self::Visible => ffi::WEBKIT_SNAPSHOT_REGION_VISIBLE,
      Self::FullDocument => ffi::WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotRegion> for SnapshotRegion {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitSnapshotRegion) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_SNAPSHOT_REGION_VISIBLE => Self::Visible,
      ffi::WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT => Self::FullDocument,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for SnapshotRegion {
  #[inline]
  #[doc(alias = "webkit_snapshot_region_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_snapshot_region_get_type()) }
  }
}

impl glib::HasParamSpec for SnapshotRegion {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for SnapshotRegion {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SnapshotRegion {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for SnapshotRegion {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<SnapshotRegion> for glib::Value {
  #[inline]
  fn from(v: SnapshotRegion) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitTLSErrorsPolicy")]
pub enum TLSErrorsPolicy {
  #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_IGNORE")]
  Ignore,
  #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_FAIL")]
  Fail,
  #[doc(hidden)]
  __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TLSErrorsPolicy {
  type GlibType = ffi::WebKitTLSErrorsPolicy;

  #[inline]
  fn into_glib(self) -> ffi::WebKitTLSErrorsPolicy {
    match self {
      Self::Ignore => ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE,
      Self::Fail => ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL,
      Self::__Unknown(value) => value,
    }
  }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitTLSErrorsPolicy> for TLSErrorsPolicy {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitTLSErrorsPolicy) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE => Self::Ignore,
      ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL => Self::Fail,
      value => Self::__Unknown(value),
    }
  }
}

impl StaticType for TLSErrorsPolicy {
  #[inline]
  #[doc(alias = "webkit_tls_errors_policy_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_tls_errors_policy_get_type()) }
  }
}

impl glib::HasParamSpec for TLSErrorsPolicy {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

impl glib::value::ValueType for TLSErrorsPolicy {
  type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TLSErrorsPolicy {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

impl ToValue for TLSErrorsPolicy {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

impl From<TLSErrorsPolicy> for glib::Value {
  #[inline]
  fn from(v: TLSErrorsPolicy) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserContentFilterError")]
pub enum UserContentFilterError {
  #[doc(alias = "WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE")]
  InvalidSource,
  #[doc(alias = "WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND")]
  NotFound,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl UserContentFilterError {
  #[doc(alias = "webkit_user_content_filter_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_user_content_filter_error_quark()) }
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
#[doc(hidden)]
impl IntoGlib for UserContentFilterError {
  type GlibType = ffi::WebKitUserContentFilterError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitUserContentFilterError {
    match self {
      Self::InvalidSource => ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE,
      Self::NotFound => ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentFilterError> for UserContentFilterError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitUserContentFilterError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_INVALID_SOURCE => Self::InvalidSource,
      ffi::WEBKIT_USER_CONTENT_FILTER_ERROR_NOT_FOUND => Self::NotFound,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl glib::error::ErrorDomain for UserContentFilterError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> = once_cell::sync::Lazy::new(
      || unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitUserContentFilterError\0".as_ptr() as *const _)
      },
    );
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl StaticType for UserContentFilterError {
  #[inline]
  #[doc(alias = "webkit_user_content_filter_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_user_content_filter_error_get_type()) }
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl glib::HasParamSpec for UserContentFilterError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl glib::value::ValueType for UserContentFilterError {
  type Type = Self;
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
unsafe impl<'a> glib::value::FromValue<'a> for UserContentFilterError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl ToValue for UserContentFilterError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_24")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_24")))]
impl From<UserContentFilterError> for glib::Value {
  #[inline]
  fn from(v: UserContentFilterError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserContentInjectedFrames")]
pub enum UserContentInjectedFrames {
  #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES")]
  AllFrames,
  #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_TOP_FRAME")]
  TopFrame,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserContentInjectedFrames {
  type GlibType = ffi::WebKitUserContentInjectedFrames;

  #[inline]
  fn into_glib(self) -> ffi::WebKitUserContentInjectedFrames {
    match self {
      Self::AllFrames => ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES,
      Self::TopFrame => ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentInjectedFrames> for UserContentInjectedFrames {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitUserContentInjectedFrames) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES => Self::AllFrames,
      ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME => Self::TopFrame,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl StaticType for UserContentInjectedFrames {
  #[inline]
  #[doc(alias = "webkit_user_content_injected_frames_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_user_content_injected_frames_get_type()) }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::HasParamSpec for UserContentInjectedFrames {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserContentInjectedFrames {
  type Type = Self;
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for UserContentInjectedFrames {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl ToValue for UserContentInjectedFrames {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl From<UserContentInjectedFrames> for glib::Value {
  #[inline]
  fn from(v: UserContentInjectedFrames) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserMessageError")]
pub enum UserMessageError {
  #[doc(alias = "WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE")]
  Message,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl UserMessageError {
  #[doc(alias = "webkit_user_message_error_quark")]
  pub fn quark() -> glib::Quark {
    assert_initialized_main_thread!();
    unsafe { from_glib(ffi::webkit_user_message_error_quark()) }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl IntoGlib for UserMessageError {
  type GlibType = ffi::WebKitUserMessageError;

  #[inline]
  fn into_glib(self) -> ffi::WebKitUserMessageError {
    match self {
      Self::Message => ffi::WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserMessageError> for UserMessageError {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitUserMessageError) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE => Self::Message,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::error::ErrorDomain for UserMessageError {
  #[inline]
  fn domain() -> glib::Quark {
    skip_assert_initialized!();

    static QUARK: once_cell::sync::Lazy<glib::ffi::GQuark> =
      once_cell::sync::Lazy::new(|| unsafe {
        glib::ffi::g_quark_from_static_string(b"WebKitUserMessageError\0".as_ptr() as *const _)
      });
    unsafe { from_glib(*QUARK) }
  }

  #[inline]
  fn code(self) -> i32 {
    self.into_glib()
  }

  #[inline]
  #[allow(clippy::match_single_binding)]
  fn from(code: i32) -> Option<Self> {
    skip_assert_initialized!();
    match unsafe { from_glib(code) } {
      value => Some(value),
    }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl StaticType for UserMessageError {
  #[inline]
  #[doc(alias = "webkit_user_message_error_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_user_message_error_get_type()) }
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::HasParamSpec for UserMessageError {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl glib::value::ValueType for UserMessageError {
  type Type = Self;
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
unsafe impl<'a> glib::value::FromValue<'a> for UserMessageError {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl ToValue for UserMessageError {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_28")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_28")))]
impl From<UserMessageError> for glib::Value {
  #[inline]
  fn from(v: UserMessageError) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserScriptInjectionTime")]
pub enum UserScriptInjectionTime {
  #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START")]
  Start,
  #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END")]
  End,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserScriptInjectionTime {
  type GlibType = ffi::WebKitUserScriptInjectionTime;

  #[inline]
  fn into_glib(self) -> ffi::WebKitUserScriptInjectionTime {
    match self {
      Self::Start => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START,
      Self::End => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserScriptInjectionTime> for UserScriptInjectionTime {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitUserScriptInjectionTime) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START => Self::Start,
      ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END => Self::End,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl StaticType for UserScriptInjectionTime {
  #[inline]
  #[doc(alias = "webkit_user_script_injection_time_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_user_script_injection_time_get_type()) }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::HasParamSpec for UserScriptInjectionTime {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserScriptInjectionTime {
  type Type = Self;
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for UserScriptInjectionTime {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl ToValue for UserScriptInjectionTime {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl From<UserScriptInjectionTime> for glib::Value {
  #[inline]
  fn from(v: UserScriptInjectionTime) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserStyleLevel")]
pub enum UserStyleLevel {
  #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_USER")]
  User,
  #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_AUTHOR")]
  Author,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserStyleLevel {
  type GlibType = ffi::WebKitUserStyleLevel;

  #[inline]
  fn into_glib(self) -> ffi::WebKitUserStyleLevel {
    match self {
      Self::User => ffi::WEBKIT_USER_STYLE_LEVEL_USER,
      Self::Author => ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserStyleLevel> for UserStyleLevel {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitUserStyleLevel) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_USER_STYLE_LEVEL_USER => Self::User,
      ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR => Self::Author,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl StaticType for UserStyleLevel {
  #[inline]
  #[doc(alias = "webkit_user_style_level_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_user_style_level_get_type()) }
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::HasParamSpec for UserStyleLevel {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserStyleLevel {
  type Type = Self;
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for UserStyleLevel {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl ToValue for UserStyleLevel {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_6")))]
impl From<UserStyleLevel> for glib::Value {
  #[inline]
  fn from(v: UserStyleLevel) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitWebProcessTerminationReason")]
pub enum WebProcessTerminationReason {
  #[doc(alias = "WEBKIT_WEB_PROCESS_CRASHED")]
  Crashed,
  #[doc(alias = "WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT")]
  ExceededMemoryLimit,
  #[doc(alias = "WEBKIT_WEB_PROCESS_TERMINATED_BY_API")]
  TerminatedByApi,
  #[doc(hidden)]
  __Unknown(i32),
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl IntoGlib for WebProcessTerminationReason {
  type GlibType = ffi::WebKitWebProcessTerminationReason;

  #[inline]
  fn into_glib(self) -> ffi::WebKitWebProcessTerminationReason {
    match self {
      Self::Crashed => ffi::WEBKIT_WEB_PROCESS_CRASHED,
      Self::ExceededMemoryLimit => ffi::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT,
      Self::TerminatedByApi => ffi::WEBKIT_WEB_PROCESS_TERMINATED_BY_API,
      Self::__Unknown(value) => value,
    }
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitWebProcessTerminationReason> for WebProcessTerminationReason {
  #[inline]
  unsafe fn from_glib(value: ffi::WebKitWebProcessTerminationReason) -> Self {
    skip_assert_initialized!();

    match value {
      ffi::WEBKIT_WEB_PROCESS_CRASHED => Self::Crashed,
      ffi::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT => Self::ExceededMemoryLimit,
      ffi::WEBKIT_WEB_PROCESS_TERMINATED_BY_API => Self::TerminatedByApi,
      value => Self::__Unknown(value),
    }
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
impl StaticType for WebProcessTerminationReason {
  #[inline]
  #[doc(alias = "webkit_web_process_termination_reason_get_type")]
  fn static_type() -> glib::Type {
    unsafe { from_glib(ffi::webkit_web_process_termination_reason_get_type()) }
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
impl glib::HasParamSpec for WebProcessTerminationReason {
  type ParamSpec = glib::ParamSpecEnum;
  type SetValue = Self;
  type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

  fn param_spec_builder() -> Self::BuilderFn {
    Self::ParamSpec::builder_with_default
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
impl glib::value::ValueType for WebProcessTerminationReason {
  type Type = Self;
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebProcessTerminationReason {
  type Checker = glib::value::GenericValueTypeChecker<Self>;

  #[inline]
  unsafe fn from_value(value: &'a glib::Value) -> Self {
    skip_assert_initialized!();
    from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
impl ToValue for WebProcessTerminationReason {
  #[inline]
  fn to_value(&self) -> glib::Value {
    let mut value = glib::Value::for_value_type::<Self>();
    unsafe {
      glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
    }
    value
  }

  #[inline]
  fn value_type(&self) -> glib::Type {
    Self::static_type()
  }
}

#[cfg(feature = "v2_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v2_20")))]
impl From<WebProcessTerminationReason> for glib::Value {
  #[inline]
  fn from(v: WebProcessTerminationReason) -> Self {
    skip_assert_initialized!();
    ToValue::to_value(&v)
  }
}
