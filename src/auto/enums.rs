// This file was generated by gir (https://github.com/gtk-rs/gir @ 8b9d0bb)
// from gir-files (https://github.com/gtk-rs/gir-files @ 77d1f70)
// DO NOT EDIT

use ffi;
use glib::StaticType;
use glib::Type;
use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib_ffi;
use gobject_ffi;

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum AuthenticationScheme {
    Default,
    HttpBasic,
    HttpDigest,
    HtmlForm,
    Ntlm,
    Negotiate,
    ClientCertificateRequested,
    ServerTrustEvaluationRequested,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for AuthenticationScheme {
    type GlibType = ffi::WebKitAuthenticationScheme;

    fn to_glib(&self) -> ffi::WebKitAuthenticationScheme {
        match *self {
            AuthenticationScheme::Default => ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT,
            AuthenticationScheme::HttpBasic => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC,
            AuthenticationScheme::HttpDigest => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST,
            AuthenticationScheme::HtmlForm => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM,
            AuthenticationScheme::Ntlm => ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM,
            AuthenticationScheme::Negotiate => ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE,
            AuthenticationScheme::ClientCertificateRequested => ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED,
            AuthenticationScheme::ServerTrustEvaluationRequested => ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED,
            AuthenticationScheme::Unknown => ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN,
            AuthenticationScheme::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAuthenticationScheme> for AuthenticationScheme {
    fn from_glib(value: ffi::WebKitAuthenticationScheme) -> Self {
        skip_assert_initialized!();
        match value {
            1 => AuthenticationScheme::Default,
            2 => AuthenticationScheme::HttpBasic,
            3 => AuthenticationScheme::HttpDigest,
            4 => AuthenticationScheme::HtmlForm,
            5 => AuthenticationScheme::Ntlm,
            6 => AuthenticationScheme::Negotiate,
            7 => AuthenticationScheme::ClientCertificateRequested,
            8 => AuthenticationScheme::ServerTrustEvaluationRequested,
            100 => AuthenticationScheme::Unknown,
            value => AuthenticationScheme::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl StaticType for AuthenticationScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_authentication_scheme_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for AuthenticationScheme {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValue<'a> for AuthenticationScheme {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl SetValue for AuthenticationScheme {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CacheModel {
    DocumentViewer,
    WebBrowser,
    DocumentBrowser,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CacheModel {
    type GlibType = ffi::WebKitCacheModel;

    fn to_glib(&self) -> ffi::WebKitCacheModel {
        match *self {
            CacheModel::DocumentViewer => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER,
            CacheModel::WebBrowser => ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER,
            CacheModel::DocumentBrowser => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER,
            CacheModel::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCacheModel> for CacheModel {
    fn from_glib(value: ffi::WebKitCacheModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CacheModel::DocumentViewer,
            1 => CacheModel::WebBrowser,
            2 => CacheModel::DocumentBrowser,
            value => CacheModel::__Unknown(value),
        }
    }
}

impl StaticType for CacheModel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cache_model_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CacheModel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CacheModel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CacheModel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ContextMenuAction {
    NoAction,
    OpenLink,
    OpenLinkInNewWindow,
    DownloadLinkToDisk,
    CopyLinkToClipboard,
    OpenImageInNewWindow,
    DownloadImageToDisk,
    CopyImageToClipboard,
    CopyImageUrlToClipboard,
    OpenFrameInNewWindow,
    GoBack,
    GoForward,
    Stop,
    Reload,
    Copy,
    Cut,
    Paste,
    Delete,
    SelectAll,
    InputMethods,
    Unicode,
    SpellingGuess,
    NoGuessesFound,
    IgnoreSpelling,
    LearnSpelling,
    IgnoreGrammar,
    FontMenu,
    Bold,
    Italic,
    Underline,
    Outline,
    InspectElement,
    OpenVideoInNewWindow,
    OpenAudioInNewWindow,
    CopyVideoLinkToClipboard,
    CopyAudioLinkToClipboard,
    ToggleMediaControls,
    ToggleMediaLoop,
    EnterVideoFullscreen,
    MediaPlay,
    MediaPause,
    MediaMute,
    DownloadVideoToDisk,
    DownloadAudioToDisk,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ContextMenuAction {
    type GlibType = ffi::WebKitContextMenuAction;

    fn to_glib(&self) -> ffi::WebKitContextMenuAction {
        match *self {
            ContextMenuAction::NoAction => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION,
            ContextMenuAction::OpenLink => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK,
            ContextMenuAction::OpenLinkInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW,
            ContextMenuAction::DownloadLinkToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK,
            ContextMenuAction::CopyLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD,
            ContextMenuAction::OpenImageInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW,
            ContextMenuAction::DownloadImageToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK,
            ContextMenuAction::CopyImageToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD,
            ContextMenuAction::CopyImageUrlToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_URL_TO_CLIPBOARD,
            ContextMenuAction::OpenFrameInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW,
            ContextMenuAction::GoBack => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK,
            ContextMenuAction::GoForward => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD,
            ContextMenuAction::Stop => ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP,
            ContextMenuAction::Reload => ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD,
            ContextMenuAction::Copy => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY,
            ContextMenuAction::Cut => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT,
            ContextMenuAction::Paste => ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE,
            ContextMenuAction::Delete => ffi::WEBKIT_CONTEXT_MENU_ACTION_DELETE,
            ContextMenuAction::SelectAll => ffi::WEBKIT_CONTEXT_MENU_ACTION_SELECT_ALL,
            ContextMenuAction::InputMethods => ffi::WEBKIT_CONTEXT_MENU_ACTION_INPUT_METHODS,
            ContextMenuAction::Unicode => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNICODE,
            ContextMenuAction::SpellingGuess => ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS,
            ContextMenuAction::NoGuessesFound => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND,
            ContextMenuAction::IgnoreSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING,
            ContextMenuAction::LearnSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING,
            ContextMenuAction::IgnoreGrammar => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR,
            ContextMenuAction::FontMenu => ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU,
            ContextMenuAction::Bold => ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD,
            ContextMenuAction::Italic => ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC,
            ContextMenuAction::Underline => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE,
            ContextMenuAction::Outline => ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE,
            ContextMenuAction::InspectElement => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT,
            ContextMenuAction::OpenVideoInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW,
            ContextMenuAction::OpenAudioInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW,
            ContextMenuAction::CopyVideoLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD,
            ContextMenuAction::CopyAudioLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD,
            ContextMenuAction::ToggleMediaControls => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS,
            ContextMenuAction::ToggleMediaLoop => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP,
            ContextMenuAction::EnterVideoFullscreen => ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN,
            ContextMenuAction::MediaPlay => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY,
            ContextMenuAction::MediaPause => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE,
            ContextMenuAction::MediaMute => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE,
            ContextMenuAction::DownloadVideoToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK,
            ContextMenuAction::DownloadAudioToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK,
            ContextMenuAction::Custom => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM,
            ContextMenuAction::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitContextMenuAction> for ContextMenuAction {
    fn from_glib(value: ffi::WebKitContextMenuAction) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ContextMenuAction::NoAction,
            1 => ContextMenuAction::OpenLink,
            2 => ContextMenuAction::OpenLinkInNewWindow,
            3 => ContextMenuAction::DownloadLinkToDisk,
            4 => ContextMenuAction::CopyLinkToClipboard,
            5 => ContextMenuAction::OpenImageInNewWindow,
            6 => ContextMenuAction::DownloadImageToDisk,
            7 => ContextMenuAction::CopyImageToClipboard,
            8 => ContextMenuAction::CopyImageUrlToClipboard,
            9 => ContextMenuAction::OpenFrameInNewWindow,
            10 => ContextMenuAction::GoBack,
            11 => ContextMenuAction::GoForward,
            12 => ContextMenuAction::Stop,
            13 => ContextMenuAction::Reload,
            14 => ContextMenuAction::Copy,
            15 => ContextMenuAction::Cut,
            16 => ContextMenuAction::Paste,
            17 => ContextMenuAction::Delete,
            18 => ContextMenuAction::SelectAll,
            19 => ContextMenuAction::InputMethods,
            20 => ContextMenuAction::Unicode,
            21 => ContextMenuAction::SpellingGuess,
            22 => ContextMenuAction::NoGuessesFound,
            23 => ContextMenuAction::IgnoreSpelling,
            24 => ContextMenuAction::LearnSpelling,
            25 => ContextMenuAction::IgnoreGrammar,
            26 => ContextMenuAction::FontMenu,
            27 => ContextMenuAction::Bold,
            28 => ContextMenuAction::Italic,
            29 => ContextMenuAction::Underline,
            30 => ContextMenuAction::Outline,
            31 => ContextMenuAction::InspectElement,
            32 => ContextMenuAction::OpenVideoInNewWindow,
            33 => ContextMenuAction::OpenAudioInNewWindow,
            34 => ContextMenuAction::CopyVideoLinkToClipboard,
            35 => ContextMenuAction::CopyAudioLinkToClipboard,
            36 => ContextMenuAction::ToggleMediaControls,
            37 => ContextMenuAction::ToggleMediaLoop,
            38 => ContextMenuAction::EnterVideoFullscreen,
            39 => ContextMenuAction::MediaPlay,
            40 => ContextMenuAction::MediaPause,
            41 => ContextMenuAction::MediaMute,
            42 => ContextMenuAction::DownloadVideoToDisk,
            43 => ContextMenuAction::DownloadAudioToDisk,
            10000 => ContextMenuAction::Custom,
            value => ContextMenuAction::__Unknown(value),
        }
    }
}

impl StaticType for ContextMenuAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_context_menu_action_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ContextMenuAction {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ContextMenuAction {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ContextMenuAction {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CookieAcceptPolicy {
    Always,
    Never,
    NoThirdParty,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CookieAcceptPolicy {
    type GlibType = ffi::WebKitCookieAcceptPolicy;

    fn to_glib(&self) -> ffi::WebKitCookieAcceptPolicy {
        match *self {
            CookieAcceptPolicy::Always => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS,
            CookieAcceptPolicy::Never => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER,
            CookieAcceptPolicy::NoThirdParty => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
            CookieAcceptPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookieAcceptPolicy> for CookieAcceptPolicy {
    fn from_glib(value: ffi::WebKitCookieAcceptPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookieAcceptPolicy::Always,
            1 => CookieAcceptPolicy::Never,
            2 => CookieAcceptPolicy::NoThirdParty,
            value => CookieAcceptPolicy::__Unknown(value),
        }
    }
}

impl StaticType for CookieAcceptPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_accept_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookieAcceptPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookieAcceptPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookieAcceptPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CookiePersistentStorage {
    Text,
    Sqlite,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for CookiePersistentStorage {
    type GlibType = ffi::WebKitCookiePersistentStorage;

    fn to_glib(&self) -> ffi::WebKitCookiePersistentStorage {
        match *self {
            CookiePersistentStorage::Text => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT,
            CookiePersistentStorage::Sqlite => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE,
            CookiePersistentStorage::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookiePersistentStorage> for CookiePersistentStorage {
    fn from_glib(value: ffi::WebKitCookiePersistentStorage) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookiePersistentStorage::Text,
            1 => CookiePersistentStorage::Sqlite,
            value => CookiePersistentStorage::__Unknown(value),
        }
    }
}

impl StaticType for CookiePersistentStorage {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_persistent_storage_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CookiePersistentStorage {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CookiePersistentStorage {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CookiePersistentStorage {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CredentialPersistence {
    None,
    ForSession,
    Permanent,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for CredentialPersistence {
    type GlibType = ffi::WebKitCredentialPersistence;

    fn to_glib(&self) -> ffi::WebKitCredentialPersistence {
        match *self {
            CredentialPersistence::None => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE,
            CredentialPersistence::ForSession => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION,
            CredentialPersistence::Permanent => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT,
            CredentialPersistence::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitCredentialPersistence> for CredentialPersistence {
    fn from_glib(value: ffi::WebKitCredentialPersistence) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CredentialPersistence::None,
            1 => CredentialPersistence::ForSession,
            2 => CredentialPersistence::Permanent,
            value => CredentialPersistence::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl StaticType for CredentialPersistence {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_credential_persistence_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValueOptional<'a> for CredentialPersistence {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl<'a> FromValue<'a> for CredentialPersistence {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
impl SetValue for CredentialPersistence {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum DownloadError {
    Network,
    CancelledByUser,
    Destination,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for DownloadError {
    type GlibType = ffi::WebKitDownloadError;

    fn to_glib(&self) -> ffi::WebKitDownloadError {
        match *self {
            DownloadError::Network => ffi::WEBKIT_DOWNLOAD_ERROR_NETWORK,
            DownloadError::CancelledByUser => ffi::WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER,
            DownloadError::Destination => ffi::WEBKIT_DOWNLOAD_ERROR_DESTINATION,
            DownloadError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitDownloadError> for DownloadError {
    fn from_glib(value: ffi::WebKitDownloadError) -> Self {
        skip_assert_initialized!();
        match value {
            499 => DownloadError::Network,
            400 => DownloadError::CancelledByUser,
            401 => DownloadError::Destination,
            value => DownloadError::__Unknown(value),
        }
    }
}

impl ErrorDomain for DownloadError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_download_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            499 => Some(DownloadError::Network),
            400 => Some(DownloadError::CancelledByUser),
            401 => Some(DownloadError::Destination),
            value => Some(DownloadError::__Unknown(value)),
        }
    }
}

impl StaticType for DownloadError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_download_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DownloadError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DownloadError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DownloadError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum FaviconDatabaseError {
    NotInitialized,
    FaviconNotFound,
    FaviconUnknown,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for FaviconDatabaseError {
    type GlibType = ffi::WebKitFaviconDatabaseError;

    fn to_glib(&self) -> ffi::WebKitFaviconDatabaseError {
        match *self {
            FaviconDatabaseError::NotInitialized => ffi::WEBKIT_FAVICON_DATABASE_ERROR_NOT_INITIALIZED,
            FaviconDatabaseError::FaviconNotFound => ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_NOT_FOUND,
            FaviconDatabaseError::FaviconUnknown => ffi::WEBKIT_FAVICON_DATABASE_ERROR_FAVICON_UNKNOWN,
            FaviconDatabaseError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitFaviconDatabaseError> for FaviconDatabaseError {
    fn from_glib(value: ffi::WebKitFaviconDatabaseError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => FaviconDatabaseError::NotInitialized,
            1 => FaviconDatabaseError::FaviconNotFound,
            2 => FaviconDatabaseError::FaviconUnknown,
            value => FaviconDatabaseError::__Unknown(value),
        }
    }
}

impl ErrorDomain for FaviconDatabaseError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_favicon_database_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(FaviconDatabaseError::NotInitialized),
            1 => Some(FaviconDatabaseError::FaviconNotFound),
            2 => Some(FaviconDatabaseError::FaviconUnknown),
            value => Some(FaviconDatabaseError::__Unknown(value)),
        }
    }
}

impl StaticType for FaviconDatabaseError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_favicon_database_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for FaviconDatabaseError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for FaviconDatabaseError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for FaviconDatabaseError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum HardwareAccelerationPolicy {
    OnDemand,
    Always,
    Never,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for HardwareAccelerationPolicy {
    type GlibType = ffi::WebKitHardwareAccelerationPolicy;

    fn to_glib(&self) -> ffi::WebKitHardwareAccelerationPolicy {
        match *self {
            HardwareAccelerationPolicy::OnDemand => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ON_DEMAND,
            HardwareAccelerationPolicy::Always => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS,
            HardwareAccelerationPolicy::Never => ffi::WEBKIT_HARDWARE_ACCELERATION_POLICY_NEVER,
            HardwareAccelerationPolicy::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitHardwareAccelerationPolicy> for HardwareAccelerationPolicy {
    fn from_glib(value: ffi::WebKitHardwareAccelerationPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => HardwareAccelerationPolicy::OnDemand,
            1 => HardwareAccelerationPolicy::Always,
            2 => HardwareAccelerationPolicy::Never,
            value => HardwareAccelerationPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl StaticType for HardwareAccelerationPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_hardware_acceleration_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValue<'a> for HardwareAccelerationPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl SetValue for HardwareAccelerationPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum InsecureContentEvent {
    Run,
    Displayed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for InsecureContentEvent {
    type GlibType = ffi::WebKitInsecureContentEvent;

    fn to_glib(&self) -> ffi::WebKitInsecureContentEvent {
        match *self {
            InsecureContentEvent::Run => ffi::WEBKIT_INSECURE_CONTENT_RUN,
            InsecureContentEvent::Displayed => ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED,
            InsecureContentEvent::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitInsecureContentEvent> for InsecureContentEvent {
    fn from_glib(value: ffi::WebKitInsecureContentEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InsecureContentEvent::Run,
            1 => InsecureContentEvent::Displayed,
            value => InsecureContentEvent::__Unknown(value),
        }
    }
}

impl StaticType for InsecureContentEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_insecure_content_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InsecureContentEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InsecureContentEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InsecureContentEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum JavascriptError {
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for JavascriptError {
    type GlibType = ffi::WebKitJavascriptError;

    fn to_glib(&self) -> ffi::WebKitJavascriptError {
        match *self {
            JavascriptError::Failed => ffi::WEBKIT_JAVASCRIPT_ERROR_SCRIPT_FAILED,
            JavascriptError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitJavascriptError> for JavascriptError {
    fn from_glib(value: ffi::WebKitJavascriptError) -> Self {
        skip_assert_initialized!();
        match value {
            699 => JavascriptError::Failed,
            value => JavascriptError::__Unknown(value),
        }
    }
}

impl ErrorDomain for JavascriptError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_javascript_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            699 => Some(JavascriptError::Failed),
            _ => Some(JavascriptError::Failed),
        }
    }
}

impl StaticType for JavascriptError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_javascript_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for JavascriptError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for JavascriptError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for JavascriptError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum LoadEvent {
    Started,
    Redirected,
    Committed,
    Finished,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for LoadEvent {
    type GlibType = ffi::WebKitLoadEvent;

    fn to_glib(&self) -> ffi::WebKitLoadEvent {
        match *self {
            LoadEvent::Started => ffi::WEBKIT_LOAD_STARTED,
            LoadEvent::Redirected => ffi::WEBKIT_LOAD_REDIRECTED,
            LoadEvent::Committed => ffi::WEBKIT_LOAD_COMMITTED,
            LoadEvent::Finished => ffi::WEBKIT_LOAD_FINISHED,
            LoadEvent::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitLoadEvent> for LoadEvent {
    fn from_glib(value: ffi::WebKitLoadEvent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LoadEvent::Started,
            1 => LoadEvent::Redirected,
            2 => LoadEvent::Committed,
            3 => LoadEvent::Finished,
            value => LoadEvent::__Unknown(value),
        }
    }
}

impl StaticType for LoadEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_load_event_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LoadEvent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LoadEvent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LoadEvent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NavigationType {
    LinkClicked,
    FormSubmitted,
    BackForward,
    Reload,
    FormResubmitted,
    Other,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for NavigationType {
    type GlibType = ffi::WebKitNavigationType;

    fn to_glib(&self) -> ffi::WebKitNavigationType {
        match *self {
            NavigationType::LinkClicked => ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED,
            NavigationType::FormSubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED,
            NavigationType::BackForward => ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD,
            NavigationType::Reload => ffi::WEBKIT_NAVIGATION_TYPE_RELOAD,
            NavigationType::FormResubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED,
            NavigationType::Other => ffi::WEBKIT_NAVIGATION_TYPE_OTHER,
            NavigationType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNavigationType> for NavigationType {
    fn from_glib(value: ffi::WebKitNavigationType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NavigationType::LinkClicked,
            1 => NavigationType::FormSubmitted,
            2 => NavigationType::BackForward,
            3 => NavigationType::Reload,
            4 => NavigationType::FormResubmitted,
            5 => NavigationType::Other,
            value => NavigationType::__Unknown(value),
        }
    }
}

impl StaticType for NavigationType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_navigation_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NavigationType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NavigationType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NavigationType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NetworkError {
    Failed,
    Transport,
    UnknownProtocol,
    Cancelled,
    FileDoesNotExist,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for NetworkError {
    type GlibType = ffi::WebKitNetworkError;

    fn to_glib(&self) -> ffi::WebKitNetworkError {
        match *self {
            NetworkError::Failed => ffi::WEBKIT_NETWORK_ERROR_FAILED,
            NetworkError::Transport => ffi::WEBKIT_NETWORK_ERROR_TRANSPORT,
            NetworkError::UnknownProtocol => ffi::WEBKIT_NETWORK_ERROR_UNKNOWN_PROTOCOL,
            NetworkError::Cancelled => ffi::WEBKIT_NETWORK_ERROR_CANCELLED,
            NetworkError::FileDoesNotExist => ffi::WEBKIT_NETWORK_ERROR_FILE_DOES_NOT_EXIST,
            NetworkError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkError> for NetworkError {
    fn from_glib(value: ffi::WebKitNetworkError) -> Self {
        skip_assert_initialized!();
        match value {
            399 => NetworkError::Failed,
            300 => NetworkError::Transport,
            301 => NetworkError::UnknownProtocol,
            302 => NetworkError::Cancelled,
            303 => NetworkError::FileDoesNotExist,
            value => NetworkError::__Unknown(value),
        }
    }
}

impl ErrorDomain for NetworkError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_network_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            399 => Some(NetworkError::Failed),
            300 => Some(NetworkError::Transport),
            301 => Some(NetworkError::UnknownProtocol),
            302 => Some(NetworkError::Cancelled),
            303 => Some(NetworkError::FileDoesNotExist),
            _ => Some(NetworkError::Failed),
        }
    }
}

impl StaticType for NetworkError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_network_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for NetworkError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for NetworkError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for NetworkError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum NetworkProxyMode {
    Default,
    NoProxy,
    Custom,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for NetworkProxyMode {
    type GlibType = ffi::WebKitNetworkProxyMode;

    fn to_glib(&self) -> ffi::WebKitNetworkProxyMode {
        match *self {
            NetworkProxyMode::Default => ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT,
            NetworkProxyMode::NoProxy => ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY,
            NetworkProxyMode::Custom => ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM,
            NetworkProxyMode::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkProxyMode> for NetworkProxyMode {
    fn from_glib(value: ffi::WebKitNetworkProxyMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => NetworkProxyMode::Default,
            1 => NetworkProxyMode::NoProxy,
            2 => NetworkProxyMode::Custom,
            value => NetworkProxyMode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl StaticType for NetworkProxyMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_network_proxy_mode_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for NetworkProxyMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl<'a> FromValue<'a> for NetworkProxyMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
impl SetValue for NetworkProxyMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PluginError {
    Failed,
    CannotFindPlugin,
    CannotLoadPlugin,
    JavaUnavailable,
    ConnectionCancelled,
    WillHandleLoad,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PluginError {
    type GlibType = ffi::WebKitPluginError;

    fn to_glib(&self) -> ffi::WebKitPluginError {
        match *self {
            PluginError::Failed => ffi::WEBKIT_PLUGIN_ERROR_FAILED,
            PluginError::CannotFindPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_FIND_PLUGIN,
            PluginError::CannotLoadPlugin => ffi::WEBKIT_PLUGIN_ERROR_CANNOT_LOAD_PLUGIN,
            PluginError::JavaUnavailable => ffi::WEBKIT_PLUGIN_ERROR_JAVA_UNAVAILABLE,
            PluginError::ConnectionCancelled => ffi::WEBKIT_PLUGIN_ERROR_CONNECTION_CANCELLED,
            PluginError::WillHandleLoad => ffi::WEBKIT_PLUGIN_ERROR_WILL_HANDLE_LOAD,
            PluginError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPluginError> for PluginError {
    fn from_glib(value: ffi::WebKitPluginError) -> Self {
        skip_assert_initialized!();
        match value {
            299 => PluginError::Failed,
            200 => PluginError::CannotFindPlugin,
            201 => PluginError::CannotLoadPlugin,
            202 => PluginError::JavaUnavailable,
            203 => PluginError::ConnectionCancelled,
            204 => PluginError::WillHandleLoad,
            value => PluginError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PluginError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_plugin_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            299 => Some(PluginError::Failed),
            200 => Some(PluginError::CannotFindPlugin),
            201 => Some(PluginError::CannotLoadPlugin),
            202 => Some(PluginError::JavaUnavailable),
            203 => Some(PluginError::ConnectionCancelled),
            204 => Some(PluginError::WillHandleLoad),
            _ => Some(PluginError::Failed),
        }
    }
}

impl StaticType for PluginError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_plugin_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PluginError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PluginError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PluginError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PolicyDecisionType {
    NavigationAction,
    NewWindowAction,
    Response,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PolicyDecisionType {
    type GlibType = ffi::WebKitPolicyDecisionType;

    fn to_glib(&self) -> ffi::WebKitPolicyDecisionType {
        match *self {
            PolicyDecisionType::NavigationAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION,
            PolicyDecisionType::NewWindowAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION,
            PolicyDecisionType::Response => ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE,
            PolicyDecisionType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyDecisionType> for PolicyDecisionType {
    fn from_glib(value: ffi::WebKitPolicyDecisionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PolicyDecisionType::NavigationAction,
            1 => PolicyDecisionType::NewWindowAction,
            2 => PolicyDecisionType::Response,
            value => PolicyDecisionType::__Unknown(value),
        }
    }
}

impl StaticType for PolicyDecisionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_policy_decision_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyDecisionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyDecisionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyDecisionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PolicyError {
    Failed,
    CannotShowMimeType,
    CannotShowUri,
    FrameLoadInterruptedByPolicyChange,
    CannotUseRestrictedPort,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PolicyError {
    type GlibType = ffi::WebKitPolicyError;

    fn to_glib(&self) -> ffi::WebKitPolicyError {
        match *self {
            PolicyError::Failed => ffi::WEBKIT_POLICY_ERROR_FAILED,
            PolicyError::CannotShowMimeType => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_MIME_TYPE,
            PolicyError::CannotShowUri => ffi::WEBKIT_POLICY_ERROR_CANNOT_SHOW_URI,
            PolicyError::FrameLoadInterruptedByPolicyChange => ffi::WEBKIT_POLICY_ERROR_FRAME_LOAD_INTERRUPTED_BY_POLICY_CHANGE,
            PolicyError::CannotUseRestrictedPort => ffi::WEBKIT_POLICY_ERROR_CANNOT_USE_RESTRICTED_PORT,
            PolicyError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyError> for PolicyError {
    fn from_glib(value: ffi::WebKitPolicyError) -> Self {
        skip_assert_initialized!();
        match value {
            199 => PolicyError::Failed,
            100 => PolicyError::CannotShowMimeType,
            101 => PolicyError::CannotShowUri,
            102 => PolicyError::FrameLoadInterruptedByPolicyChange,
            103 => PolicyError::CannotUseRestrictedPort,
            value => PolicyError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PolicyError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_policy_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            199 => Some(PolicyError::Failed),
            100 => Some(PolicyError::CannotShowMimeType),
            101 => Some(PolicyError::CannotShowUri),
            102 => Some(PolicyError::FrameLoadInterruptedByPolicyChange),
            103 => Some(PolicyError::CannotUseRestrictedPort),
            _ => Some(PolicyError::Failed),
        }
    }
}

impl StaticType for PolicyError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_policy_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PolicyError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PolicyError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PolicyError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintError {
    General,
    PrinterNotFound,
    InvalidPageRange,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintError {
    type GlibType = ffi::WebKitPrintError;

    fn to_glib(&self) -> ffi::WebKitPrintError {
        match *self {
            PrintError::General => ffi::WEBKIT_PRINT_ERROR_GENERAL,
            PrintError::PrinterNotFound => ffi::WEBKIT_PRINT_ERROR_PRINTER_NOT_FOUND,
            PrintError::InvalidPageRange => ffi::WEBKIT_PRINT_ERROR_INVALID_PAGE_RANGE,
            PrintError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintError> for PrintError {
    fn from_glib(value: ffi::WebKitPrintError) -> Self {
        skip_assert_initialized!();
        match value {
            599 => PrintError::General,
            500 => PrintError::PrinterNotFound,
            501 => PrintError::InvalidPageRange,
            value => PrintError::__Unknown(value),
        }
    }
}

impl ErrorDomain for PrintError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_print_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            599 => Some(PrintError::General),
            500 => Some(PrintError::PrinterNotFound),
            501 => Some(PrintError::InvalidPageRange),
            value => Some(PrintError::__Unknown(value)),
        }
    }
}

impl StaticType for PrintError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_print_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PrintOperationResponse {
    Print,
    Cancel,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for PrintOperationResponse {
    type GlibType = ffi::WebKitPrintOperationResponse;

    fn to_glib(&self) -> ffi::WebKitPrintOperationResponse {
        match *self {
            PrintOperationResponse::Print => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_PRINT,
            PrintOperationResponse::Cancel => ffi::WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL,
            PrintOperationResponse::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPrintOperationResponse> for PrintOperationResponse {
    fn from_glib(value: ffi::WebKitPrintOperationResponse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PrintOperationResponse::Print,
            1 => PrintOperationResponse::Cancel,
            value => PrintOperationResponse::__Unknown(value),
        }
    }
}

impl StaticType for PrintOperationResponse {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_print_operation_response_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PrintOperationResponse {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PrintOperationResponse {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PrintOperationResponse {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ProcessModel {
    SharedSecondaryProcess,
    MultipleSecondaryProcesses,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for ProcessModel {
    type GlibType = ffi::WebKitProcessModel;

    fn to_glib(&self) -> ffi::WebKitProcessModel {
        match *self {
            ProcessModel::SharedSecondaryProcess => ffi::WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS,
            ProcessModel::MultipleSecondaryProcesses => ffi::WEBKIT_PROCESS_MODEL_MULTIPLE_SECONDARY_PROCESSES,
            ProcessModel::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitProcessModel> for ProcessModel {
    fn from_glib(value: ffi::WebKitProcessModel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ProcessModel::SharedSecondaryProcess,
            1 => ProcessModel::MultipleSecondaryProcesses,
            value => ProcessModel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl StaticType for ProcessModel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_process_model_get_type()) }
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl<'a> FromValueOptional<'a> for ProcessModel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl<'a> FromValue<'a> for ProcessModel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_4", feature = "dox"))]
impl SetValue for ProcessModel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SaveMode {
    Mhtml,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SaveMode {
    type GlibType = ffi::WebKitSaveMode;

    fn to_glib(&self) -> ffi::WebKitSaveMode {
        match *self {
            SaveMode::Mhtml => ffi::WEBKIT_SAVE_MODE_MHTML,
            SaveMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSaveMode> for SaveMode {
    fn from_glib(value: ffi::WebKitSaveMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SaveMode::Mhtml,
            value => SaveMode::__Unknown(value),
        }
    }
}

impl StaticType for SaveMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_save_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SaveMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SaveMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SaveMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum ScriptDialogType {
    Alert,
    Confirm,
    Prompt,
    BeforeUnloadConfirm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for ScriptDialogType {
    type GlibType = ffi::WebKitScriptDialogType;

    fn to_glib(&self) -> ffi::WebKitScriptDialogType {
        match *self {
            ScriptDialogType::Alert => ffi::WEBKIT_SCRIPT_DIALOG_ALERT,
            ScriptDialogType::Confirm => ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM,
            ScriptDialogType::Prompt => ffi::WEBKIT_SCRIPT_DIALOG_PROMPT,
            ScriptDialogType::BeforeUnloadConfirm => ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM,
            ScriptDialogType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitScriptDialogType> for ScriptDialogType {
    fn from_glib(value: ffi::WebKitScriptDialogType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ScriptDialogType::Alert,
            1 => ScriptDialogType::Confirm,
            2 => ScriptDialogType::Prompt,
            3 => ScriptDialogType::BeforeUnloadConfirm,
            value => ScriptDialogType::__Unknown(value),
        }
    }
}

impl StaticType for ScriptDialogType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_script_dialog_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ScriptDialogType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ScriptDialogType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ScriptDialogType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SnapshotError {
    Create,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SnapshotError {
    type GlibType = ffi::WebKitSnapshotError;

    fn to_glib(&self) -> ffi::WebKitSnapshotError {
        match *self {
            SnapshotError::Create => ffi::WEBKIT_SNAPSHOT_ERROR_FAILED_TO_CREATE,
            SnapshotError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotError> for SnapshotError {
    fn from_glib(value: ffi::WebKitSnapshotError) -> Self {
        skip_assert_initialized!();
        match value {
            799 => SnapshotError::Create,
            value => SnapshotError::__Unknown(value),
        }
    }
}

impl ErrorDomain for SnapshotError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::webkit_snapshot_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            799 => Some(SnapshotError::Create),
            value => Some(SnapshotError::__Unknown(value)),
        }
    }
}

impl StaticType for SnapshotError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_snapshot_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum SnapshotRegion {
    Visible,
    FullDocument,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for SnapshotRegion {
    type GlibType = ffi::WebKitSnapshotRegion;

    fn to_glib(&self) -> ffi::WebKitSnapshotRegion {
        match *self {
            SnapshotRegion::Visible => ffi::WEBKIT_SNAPSHOT_REGION_VISIBLE,
            SnapshotRegion::FullDocument => ffi::WEBKIT_SNAPSHOT_REGION_FULL_DOCUMENT,
            SnapshotRegion::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSnapshotRegion> for SnapshotRegion {
    fn from_glib(value: ffi::WebKitSnapshotRegion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SnapshotRegion::Visible,
            1 => SnapshotRegion::FullDocument,
            value => SnapshotRegion::__Unknown(value),
        }
    }
}

impl StaticType for SnapshotRegion {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_snapshot_region_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SnapshotRegion {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SnapshotRegion {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SnapshotRegion {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum TLSErrorsPolicy {
    Ignore,
    Fail,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for TLSErrorsPolicy {
    type GlibType = ffi::WebKitTLSErrorsPolicy;

    fn to_glib(&self) -> ffi::WebKitTLSErrorsPolicy {
        match *self {
            TLSErrorsPolicy::Ignore => ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE,
            TLSErrorsPolicy::Fail => ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL,
            TLSErrorsPolicy::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitTLSErrorsPolicy> for TLSErrorsPolicy {
    fn from_glib(value: ffi::WebKitTLSErrorsPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => TLSErrorsPolicy::Ignore,
            1 => TLSErrorsPolicy::Fail,
            value => TLSErrorsPolicy::__Unknown(value),
        }
    }
}

impl StaticType for TLSErrorsPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_tls_errors_policy_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for TLSErrorsPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for TLSErrorsPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for TLSErrorsPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum UserContentInjectedFrames {
    AllFrames,
    TopFrame,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserContentInjectedFrames {
    type GlibType = ffi::WebKitUserContentInjectedFrames;

    fn to_glib(&self) -> ffi::WebKitUserContentInjectedFrames {
        match *self {
            UserContentInjectedFrames::AllFrames => ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES,
            UserContentInjectedFrames::TopFrame => ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME,
            UserContentInjectedFrames::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentInjectedFrames> for UserContentInjectedFrames {
    fn from_glib(value: ffi::WebKitUserContentInjectedFrames) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserContentInjectedFrames::AllFrames,
            1 => UserContentInjectedFrames::TopFrame,
            value => UserContentInjectedFrames::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserContentInjectedFrames {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_content_injected_frames_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserContentInjectedFrames {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserContentInjectedFrames {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserContentInjectedFrames {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum UserScriptInjectionTime {
    Start,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserScriptInjectionTime {
    type GlibType = ffi::WebKitUserScriptInjectionTime;

    fn to_glib(&self) -> ffi::WebKitUserScriptInjectionTime {
        match *self {
            UserScriptInjectionTime::Start => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START,
            UserScriptInjectionTime::End => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END,
            UserScriptInjectionTime::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserScriptInjectionTime> for UserScriptInjectionTime {
    fn from_glib(value: ffi::WebKitUserScriptInjectionTime) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserScriptInjectionTime::Start,
            1 => UserScriptInjectionTime::End,
            value => UserScriptInjectionTime::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserScriptInjectionTime {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_script_injection_time_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserScriptInjectionTime {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserScriptInjectionTime {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserScriptInjectionTime {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum UserStyleLevel {
    User,
    Author,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for UserStyleLevel {
    type GlibType = ffi::WebKitUserStyleLevel;

    fn to_glib(&self) -> ffi::WebKitUserStyleLevel {
        match *self {
            UserStyleLevel::User => ffi::WEBKIT_USER_STYLE_LEVEL_USER,
            UserStyleLevel::Author => ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR,
            UserStyleLevel::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserStyleLevel> for UserStyleLevel {
    fn from_glib(value: ffi::WebKitUserStyleLevel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => UserStyleLevel::User,
            1 => UserStyleLevel::Author,
            value => UserStyleLevel::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl StaticType for UserStyleLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_style_level_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValueOptional<'a> for UserStyleLevel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl<'a> FromValue<'a> for UserStyleLevel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
impl SetValue for UserStyleLevel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

